#  plot a sparse matrix data set generated by Biodiverse as a correlogram

plot_correlogram = function (data, fld='Value', dist_fld="distance", modifier=1, max_dist=0, lag=0, xlab='distance', ylab='dissimilarity', ...) {  
  #browser()
  dist_fld_text = dist_fld
  if (is.numeric (dist_fld)) {dist_fld_text = names(data)[dist_fld]}

  if (! (dist_fld_text %in% colnames (data))) {
    stop (paste ("data frame does not have the specified distance field:", dist_fld))
  }
  if (max_dist && max_dist < min (data[[dist_fld]])) {
    stop (paste ("max_dist value is less than minimum distance in the data set:", max_dist, dist_fld))
  }
  if (!lag) {
    lag = floor (max (data[[dist_fld]] / 10))
  }

  if (max_dist) {
    data2 = subset (data, data[[dist_fld]] <= max_dist)
  } else {
    data2 = data
  }
  mod_lag  = lag / modifier
  mod_lag2 = mod_lag / 2
  lag_vector = floor (data2[[dist_fld]] / lag) * mod_lag #+ mod_lag2

  fld_text = fld  
  if (is.numeric (fld)) {fld_text = names(data2)[fld]}

  print (paste0 ("Plotting ", fld_text, " against ", dist_fld_text))

  boxplot(data2[[fld]] ~ lag_vector, xlab=xlab, ylab=ylab, ...)
}

plot_correlogram_dir = function (data,
                                 start=0,
                                 end=pi,
                                 incr=pi/18,
                                 wedge_width=pi/18,
                                 modifier = 1,
                                 max_dist=0,
                                 lag=1,
                                 fld='Value',
                                 ...) {
  data = data
  modifier = modifier
  max_dist = max_dist
  lag = lag
  for (i in seq(start, end, incr)) {
    data2 = subset_by_dir (data, wedge_angle=i, wedge_width=wedge_width)
    plot_correlogram (data2, fld=fld, modifier=modifier, max_dist=max_dist, lag=lag)
    deg   = formatC(radians2degrees (i))
    deg_r = formatC(radians2degrees (i+pi))  #  rotated 180
    title = paste (deg, '/', deg_r, sep=' ')
    title (title)
  }
}

subset_by_dir = function (data, dirfld='direction', wedge_angle=0, wedge_width=pi/18) {
  w = wedge_width / 2
  min_angle1 = wedge_angle - w  
  max_angle1 = wedge_angle + w
  min_angle2 = min_angle1 + pi   #  Allow for round-the-circle in either direction.
  max_angle2 = max_angle1 + pi   #  Surely this can be done better?
  min_angle3 = min_angle1 - pi
  max_angle3 = max_angle1 - pi
  
  return (
    subset (data,
              (min_angle1 <= data[[dirfld]] & data[[dirfld]] <= max_angle1)
            | (min_angle2 <= data[[dirfld]] & data[[dirfld]] <= max_angle2)
            | (min_angle3 <= data[[dirfld]] & data[[dirfld]] <= max_angle3)
    )
  )
}

radians2degrees = function (angle) {
  a = angle %% (2 * pi)          #  snap to interval [0,2PI]
  a = 1.25 - (a / (2 * pi))      #  invert and rotate
  a = a %% 1                     #  snap to unit interval
  a = 360 * a
  return (a)
}


calc_distance = function (df) {
  distance = ((df$x1 - df$x2) ^ 2 + (df$y1 - df$y2) ^ 2 ) ^ 0.5
  return (distance)
}
